"""AiiDA-ORCA input generator"""
import os
import collections

from copy import deepcopy


def dict_merge(dct, merge_dct):
    """ Taken from https://gist.github.com/angstwad/bf22d1822c38a92ec0a9
    Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k in merge_dct.keys():
        if (k in dct and isinstance(dct[k], dict) and isinstance(merge_dct[k], collections.Mapping)):
            dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]


class OrcaInput:
    """Transforms dictionary into ORCA input"""

    def __init__(self, params, remote_path=None):
        """Initializing OrcaInput object"""

        self._params = deepcopy(params)

        if remote_path is not None:
            self._remote_path = remote_path
            gbw_path = os.path.join(self._remote_path, 'aiida.gbw')
            restart_params = {
                'input_blocks': {
                    'scf': {
                        'moinp': f'"{gbw_path}"',
                    },
                },
            }
            dict_merge(self._params, restart_params)

    def render(self):
        output = ['### Generated by AiiDA-ORCA Plugin ###']
        self._render_input(output, deepcopy(self._params))
        return '\n'.join(output)

    @staticmethod
    def _render_input(output, params):
        """
        Rendering differnt sections
        """
        #pylint: disable = too-many-branches
        if 'input_keywords' in params:
            keywords = params['input_keywords']
        else:
            keywords = {'SP': None}  # as a default

        if 'extra_input_keywords' in params:
            extra_keywords = params['extra_input_keywords']

        if 'input_blocks' in params:
            blocks = params['input_blocks']

        inp_keyword = '! '

        for keyword in keywords:
            inp_keyword += keyword + ' '

        output.append(inp_keyword)

        if extra_keywords:
            xtrainp_keyword = '! '
            for keyword in extra_keywords:
                xtrainp_keyword += keyword + ' '

            output.append(xtrainp_keyword)

        inp_block = ''
        if blocks:
            for key in blocks.keys():
                inp_block += f'%{key} \n'
                for keyword, val in blocks[key].items():
                    if val is None:
                        inp_block += '\t' + keyword + '\n'
                    else:
                        inp_block += '\t' + str(keyword) + ' ' + str(val) + '\n'
                inp_block += 'end\n'
        output.append(inp_block)

        #     coordinate section
        coord_sec = '* xyzfile'
        coord_sec += f" {params['charge']} {params['multiplicity']} aiida.coords.xyz\n"
        output.append(coord_sec)
